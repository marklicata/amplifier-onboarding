{
  "id": "03_custom_tool",
  "title": "Building a Custom Tool - Extending Your Agent",
  "tier": 1,
  "category": "Quick Start",
  "description": "Need a capability that doesn't exist? Build it in 20 lines.\nAmplifier's protocol-based design means ",
  "estimatedTimeMinutes": 10,
  "minAudience": "everyone",
  "isFeatured": true,
  "difficulty": "beginner",
  "tags": [
    "tools",
    "composition",
    "basics"
  ],
  "githubUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/03_custom_tool.py",
  "content": {
    "everyone": {
      "title": "Building a Custom Tool - Extending Your Agent",
      "valueProposition": "Need a capability that doesn't exist? Build it in 20 lines.\nAmplifier's protocol-based design means no inheritance, no framework lock-in.\nJust implement the contract and plug it in.",
      "howItWorks": [
        "Set up your AI environment",
        "Configure the agent with the right capabilities",
        "Run the example and see results",
        "Understand what happened"
      ],
      "whatYouGet": [
        "Working example you can run",
        "Clear understanding of the concept",
        "Foundation for building more"
      ]
    },
    "developers": {
      "title": "03_custom_tool.py - Building a Custom Tool - Extending Your Agent",
      "valueProposition": "Need a capability that doesn't exist? Build it in 20 lines.\nAmplifier's protocol-based design means no inheritance, no framework lock-in.\nJust implement the contract and plug it in.",
      "howItWorks": "- How to create a custom tool from scratch\n- The Tool contract (what methods you need)\n- How to register and use your tool\n- How tools integrate seamlessly with any orchestrator/provider",
      "keyConcepts": [
        "How to create a custom tool from scratch",
        "The Tool contract (what methods you need)",
        "How to register and use your tool",
        "How tools integrate seamlessly with any orchestrator/provider"
      ],
      "codeOverview": {
        "structure": [
          "Load foundation and provider bundles",
          "Compose bundles together",
          "Prepare modules (download if needed)",
          "Create AI session",
          "Execute prompts and get responses"
        ],
        "keyFunctions": [
          {
            "name": "load_bundle",
            "description": "Loads a bundle from path or URL",
            "usage": "load_bundle(str(foundation_path)"
          },
          {
            "name": "compose",
            "description": "Combines multiple bundles",
            "usage": "compose(provider)"
          },
          {
            "name": "prepare",
            "description": "Downloads and activates modules",
            "usage": "prepare()"
          },
          {
            "name": "create_session",
            "description": "Creates an AI session",
            "usage": "create_session()"
          },
          {
            "name": "execute",
            "description": "Executes a prompt",
            "usage": "execute()"
          },
          {
            "name": "mount",
            "description": "Registers a custom tool or component",
            "usage": "mount(\"tools\", weather, name=weather.name)"
          }
        ]
      },
      "codeSnippet": "async def demo_custom_tool():\n    \"\"\"Demonstrate using custom tools in an agent.\"\"\"\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Custom Tool Demo: Weather + Database Tools\")\n    print(\"=\" * 60)\n\n    # Load foundation and provider\n    foundation_path = Path(__file__).parent.parent  # examples/ -> amplifier-foundation/\n    foundation = await load_bundle(str(foundation_path))\n    provider = await load_bundle(str(foundation_path / \"providers\" / \"anthropic-sonnet.yaml\"))\n\n    # Add filesystem tool for fun\n    tools_config = Bundle(\n        name=\"tools-config\","
    },
    "experts": {
      "title": "03_custom_tool.py - Building a Custom Tool - Extending Your Agent",
      "complexity": "Tier 1 - Quick Start",
      "sourceUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/03_custom_tool.py",
      "architecture": "Need a capability that doesn't exist? Build it in 20 lines.\nAmplifier's protocol-based design means no inheritance, no framework lock-in.\nJust implement the contract and plug it in.",
      "fullCode": "#!/usr/bin/env python3\n\"\"\"\nExample 3: Building a Custom Tool - Extending Your Agent\n=========================================================\n\nVALUE PROPOSITION:\nNeed a capability that doesn't exist? Build it in 20 lines.\nAmplifier's protocol-based design means no inheritance, no framework lock-in.\nJust implement the contract and plug it in.\n\nWHAT YOU'LL LEARN:\n- How to create a custom tool from scratch\n- The Tool contract (what methods you need)\n- How to register and use your tool\n- How tools integrate seamlessly with any orchestrator/provider\n\nREAL-WORLD USE CASE:\nBuild a \"database query\" tool, \"API client\" tool, or \"email sender\" tool\nfor your specific domain.\n\nTIME TO VALUE: 10 minutes\n\"\"\"\n\nimport asyncio\nimport os\nfrom pathlib import Path\nfrom typing import Any\n\nfrom amplifier_core import ToolResult\nfrom amplifier_foundation import Bundle\nfrom amplifier_foundation import load_bundle\n\n# =============================================================================\n# STEP 1: Define Your Custom Tool\n# =============================================================================\n\n\nclass WeatherTool:\n    \"\"\"A custom tool that provides weather information.\n\n    This demonstrates the minimal Tool contract:\n    - name property\n    - description property\n    - input_schema property (JSON schema for parameters)\n    - execute() method\n\n    No inheritance required! Just implement the protocol.\n    \"\"\"\n\n    @property\n    def name(self) -> str:\n        \"\"\"Unique identifier for this tool.\"\"\"\n        return \"weather\"\n\n    @property\n    def description(self) -> str:\n        \"\"\"Description the LLM will see to decide when to use this tool.\"\"\"\n        return \"\"\"Get current weather for a location.\n\nInput: {\"location\": \"city name or zip code\"}\nReturns: Weather information including temperature, conditions, and forecast.\"\"\"\n\n    @property\n    def input_schema(self) -> dict:\n        \"\"\"JSON schema defining the tool's parameters.\"\"\"\n        return {\n            \"type\": \"object\",\n            \"properties\": {\"location\": {\"type\": \"string\", \"description\": \"City name or zip code\"}},\n            \"required\": [\"location\"],\n        }\n\n    async def execute(self, input: dict[str, Any]) -> ToolResult:\n        \"\"\"Execute the tool with the given input.\n\n        Args:\n            input: Dict with 'location' key\n\n        Returns:\n            ToolResult with weather information\n        \"\"\"\n        location = input.get(\"location\", \"\")\n\n        if not location:\n            return ToolResult(success=False, error={\"message\": \"No location provided\"})\n\n        # In a real tool, you'd call a weather API here\n        # For demo, we'll return mock data\n        mock_weather = {\n            \"location\": location,\n            \"temperature\": \"72\u00b0F (22\u00b0C)\",\n            \"conditions\": \"Partly cloudy\",\n            \"humidity\": \"65%\",\n            \"wind\": \"10 mph NW\",\n            \"forecast\": \"Clear skies expected through the evening\",\n        }\n\n        result_text = f\"\"\"Weather for {location}:\nTemperature: {mock_weather[\"temperature\"]}\nConditions: {mock_weather[\"conditions\"]}\nHumidity: {mock_weather[\"humidity\"]}\nWind: {mock_weather[\"wind\"]}\nForecast: {mock_weather[\"forecast\"]}\"\"\"\n\n        return ToolResult(success=True, output=result_text)\n\n\nclass DatabaseTool:\n    \"\"\"Example of a more complex custom tool - database queries.\n\n    This shows how you might build domain-specific tools for your application.\n    \"\"\"\n\n    @property\n    def name(self) -> str:\n        return \"database\"\n\n    @property\n    def description(self) -> str:\n        return \"\"\"Query the application database.\n\nInput: {\"query\": \"SQL query\", \"params\": [optional list of params]}\nReturns: Query results as JSON.\"\"\"\n\n    @property\n    def input_schema(self) -> dict:\n        \"\"\"JSON schema defining the tool's parameters.\"\"\"\n        return {\n            \"type\": \"object\",\n            \"properties\": {\n                \"query\": {\"type\": \"string\", \"description\": \"SQL query to execute\"},\n                \"params\": {\"type\": \"array\", \"description\": \"Optional query parameters\", \"items\": {\"type\": \"string\"}},\n            },\n            \"required\": [\"query\"],\n        }\n\n    async def execute(self, input: dict[str, Any]) -> ToolResult:\n        \"\"\"Execute a database query.\"\"\"\n        query = input.get(\"query\", \"\")\n\n        if not query:\n            return ToolResult(success=False, error={\"message\": \"No query provided\"})\n\n        # Mock results for demo\n        # In real tool, you'd use asyncpg, SQLAlchemy, etc.\n        if \"users\" in query.lower():\n            result = [\n                {\"id\": 1, \"name\": \"Alice\", \"email\": \"alice@example.com\"},\n                {\"id\": 2, \"name\": \"Bob\", \"email\": \"bob@example.com\"},\n            ]\n            return ToolResult(success=True, output=result)\n\n        return ToolResult(success=True, output=f\"Query executed: {query}\")\n\n\n# =============================================================================\n# STEP 2: Mount Function (Required for Module Loading)\n# =============================================================================\n\n\nasync def mount_custom_tools(coordinator, config: dict):\n    \"\"\"Mount function that registers your custom tools.\n\n    This is the bridge between your tool and Amplifier's module system.\n    The coordinator provides the registration API.\n    \"\"\"\n    # Create instances of your tools\n    weather = WeatherTool()\n    database = DatabaseTool()\n\n    # Register them with the coordinator\n    await coordinator.mount(\"tools\", weather, name=weather.name)\n    await coordinator.mount(\"tools\", database, name=database.name)\n\n    print(f\"\u2713 Registered custom tools: {weather.name}, {database.name}\")\n\n    # Optional: Return cleanup function\n    async def cleanup():\n        # Close connections, release resources, etc.\n        # In a real app: close DB connections, release file handles, etc.\n        print(\"Cleanup: releasing resources (no-op in this example)\")\n\n    return cleanup\n\n\n# =============================================================================\n# STEP 3: Use Your Custom Tool\n# =============================================================================\n\n\nasync def demo_custom_tool():\n    \"\"\"Demonstrate using custom tools in an agent.\"\"\"\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Custom Tool Demo: Weather + Database Tools\")\n    print(\"=\" * 60)\n\n    # Load foundation and provider\n    foundation_path = Path(__file__).parent.parent  # examples/ -> amplifier-foundation/\n    foundation = await load_bundle(str(foundation_path))\n    provider = await load_bundle(str(foundation_path / \"providers\" / \"anthropic-sonnet.yaml\"))\n\n    # Add filesystem tool for fun\n    tools_config = Bundle(\n        name=\"tools-config\",\n        version=\"1.0.0\",\n        tools=[\n            {\n                \"module\": \"tool-filesystem\",\n                \"source\": \"git+https://github.com/microsoft/amplifier-module-tool-filesystem@main\",\n            },\n        ],\n    )\n\n    composed = foundation.compose(provider).compose(tools_config)\n\n    print(\"\u23f3 Preparing...\")\n    prepared = await composed.prepare()\n    session = await prepared.create_session()\n\n    # Register custom tools AFTER session is created\n    await mount_custom_tools(session.coordinator, {})\n\n    # Now use the agent with your custom tools!\n    async with session:\n        print(\"\\n[Test 1: Weather Tool]\")\n        print(\"\ud83d\udcdd Asking about weather...\")\n        response1 = await session.execute(\"What's the weather like in San Francisco?\")\n        print(f\"\u2713 Response: {response1[:300]}...\")\n\n        print(\"\\n[Test 2: Database Tool]\")\n        print(\"\ud83d\udcdd Asking about database...\")\n        response2 = await session.execute(\"Query the users table and show me the results.\")\n        print(f\"\u2713 Response: {response2[:300]}...\")\n\n        print(\"\\n[Test 3: Multi-tool Usage]\")\n        print(\"\ud83d\udcdd Using multiple tools together...\")\n        response3 = await session.execute(\n            \"Check the weather in New York, then query the users table \"\n            \"and save both results to a file called 'results.txt'.\"\n        )\n        print(f\"\u2713 Response: {response3[:300]}...\")\n\n\nasync def main():\n    \"\"\"Run the custom tool demo.\"\"\"\n\n    print(\"\ud83d\udd27 Building Custom Tools with Amplifier\")\n    print(\"=\" * 60)\n    print(\"\\nWHAT YOU'LL BUILD:\")\n    print(\"- WeatherTool: Get weather for any location\")\n    print(\"- DatabaseTool: Query application database\")\n    print(\"- Pattern: Domain-specific tools for your use case\")\n    print(\"\\nKEY INSIGHT:\")\n    print(\"Tools are just classes with name, description, and execute().\")\n    print(\"No inheritance, no framework magic - just implement the protocol!\")\n\n    await demo_custom_tool()\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"\ud83d\udcda WHAT YOU LEARNED:\")\n    print(\"=\" * 60)\n    print(\"1. Tool Contract: name, description, input_schema, execute()\")\n    print(\"2. input_schema: JSON schema defining parameters (helps LLM use the tool)\")\n    print(\"3. Registration: Use coordinator.mount() to register tools\")\n    print(\"4. Integration: Custom tools work with any orchestrator/provider\")\n    print(\"5. No framework lock-in: Just implement the protocol\")\n    print(\"\\n\u2705 You can now extend Amplifier with domain-specific capabilities!\")\n    print(\"\\n\ud83d\udca1 Next: Try 08_cli_application.py for application patterns\")\n\n\nif __name__ == \"__main__\":\n    if not os.getenv(\"ANTHROPIC_API_KEY\"):\n        print(\"\u274c ERROR: Set ANTHROPIC_API_KEY environment variable\")\n        print(\"\\nExample:\")\n        print(\"  export ANTHROPIC_API_KEY='your-key-here'\")\n        print(\"  python 03_custom_tool.py\")\n        exit(1)\n\n    asyncio.run(main())\n",
      "advancedOptions": {
        "provider": [
          "anthropic-sonnet",
          "anthropic-opus",
          "openai-gpt4"
        ],
        "streaming": false,
        "hooks": []
      }
    }
  },
  "execution": {
    "requiresInput": true,
    "defaultPrompt": "What's the weather like in San Francisco?",
    "estimatedDuration": "2-5 seconds",
    "prerequisites": [
      "ANTHROPIC_API_KEY environment variable"
    ]
  }
}