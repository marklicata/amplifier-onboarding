{
  "id": "21_bundle_updates",
  "title": "Bundle Updates (Status Checking & Updating)",
  "tier": 4,
  "category": "Real-World",
  "description": "Bundle Updates (Status Checking & Updating)",
  "estimatedTimeMinutes": 5,
  "minAudience": "developers",
  "isFeatured": false,
  "difficulty": "advanced",
  "tags": [
    "tools",
    "composition"
  ],
  "githubUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/21_bundle_updates.py",
  "content": {
    "everyone": {
      "title": "Bundle Updates (Status Checking & Updating)",
      "valueProposition": "Learn to work with AI agents",
      "howItWorks": [
        "Set up your AI environment",
        "Configure the agent with the right capabilities",
        "Run the example and see results",
        "Understand what happened"
      ],
      "whatYouGet": [
        "Working example you can run",
        "Clear understanding of the concept",
        "Foundation for building more"
      ]
    },
    "developers": {
      "title": "21_bundle_updates.py - Bundle Updates (Status Checking & Updating)",
      "valueProposition": "",
      "howItWorks": "",
      "keyConcepts": [
        "Amplifier bundle system",
        "Module composition",
        "Session execution"
      ],
      "codeOverview": {
        "structure": [
          "Load foundation and provider bundles"
        ],
        "keyFunctions": [
          {
            "name": "load_bundle",
            "description": "Loads a bundle from path or URL",
            "usage": "load_bundle(str(bundle_path)"
          }
        ]
      },
      "codeSnippet": "async def main():\n    \"\"\"Run interactive demo menu.\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udd04 Bundle Updates (Status Checking & Refresh)\")\n    print(\"=\" * 80)\n    print(\"\\nVALUE: Detect and apply bundle updates without rebuilding\")\n    print(\"AUDIENCE: App developers building update workflows\")\n    print(\"\\nWhat this demonstrates:\")\n    print(\"  - Checking bundle sources for updates (no side effects)\")\n    print(\"  - Getting detailed status per source\")\n    print(\"  - Refreshing sources selectively or all at once\")\n    print(\"  - Foundation mechanism + App policy pattern\")\n\n    examples = [\n        (\"Basic Status Checking\", check_status_example),"
    },
    "experts": {
      "title": "21_bundle_updates.py - Bundle Updates (Status Checking & Updating)",
      "complexity": "Tier 4 - Real-World Applications",
      "sourceUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/21_bundle_updates.py",
      "architecture": "",
      "fullCode": "#!/usr/bin/env python3\n\"\"\"\nExample 21: Bundle Updates (Status Checking & Updating)\n=======================================================\n\nAUDIENCE: Developers building apps with bundles loaded from git sources\nVALUE: Shows how to detect and apply updates to bundles without rebuilding\nPATTERN: Check status (no side effects) \u2192 Optionally update (side effects)\n\nWhat this demonstrates:\n  - Checking if bundle sources have updates available\n  - Getting detailed status for each source in a bundle\n  - Updating specific or all sources with updates\n  - Foundation provides mechanism, app provides policy\n\nWhen you'd use this:\n  - CLI update commands (\"check for updates\", \"update all\")\n  - Startup checks (\"newer versions available\")\n  - CI/CD pipelines (ensure pinned versions haven't drifted)\n  - Development workflows (pull latest from upstream)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom pathlib import Path\n\nfrom amplifier_foundation import Bundle\nfrom amplifier_foundation import BundleStatus\nfrom amplifier_foundation import check_bundle_status\nfrom amplifier_foundation import load_bundle\nfrom amplifier_foundation import update_bundle\nfrom amplifier_foundation.sources.protocol import SourceStatus\n\n# ============================================================================\n# Example 1: Basic Status Checking\n# ============================================================================\n\n\nasync def check_status_example():\n    \"\"\"\n    Demonstrate basic bundle status checking.\n\n    This is a READ-ONLY operation - it checks for updates without\n    downloading anything. Uses `git ls-remote` for git sources.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"EXAMPLE 1: Basic Status Checking\")\n    print(\"=\" * 80)\n\n    # Load a bundle from local path (simulates any bundle source)\n    bundle_path = Path(__file__).parent.parent\n    bundle = await load_bundle(str(bundle_path))\n\n    print(f\"\\nBundle: {bundle.name}\")\n    print(f\"Source: {getattr(bundle, '_source_uri', 'local')}\")\n\n    # Check status - NO SIDE EFFECTS\n    print(\"\\n[Checking for updates...]\")\n    status = await check_bundle_status(bundle)\n\n    # Display summary\n    print(f\"\\n{status.summary}\")\n    print(f\"  Total sources: {len(status.sources)}\")\n    print(f\"  Updates available: {len(status.updateable_sources)}\")\n    print(f\"  Up to date: {len(status.up_to_date_sources)}\")\n    print(f\"  Unknown: {len(status.unknown_sources)}\")\n\n    return status\n\n\n# ============================================================================\n# Example 2: Detailed Source Status\n# ============================================================================\n\n\ndef display_source_status(source: SourceStatus, index: int):\n    \"\"\"Display detailed information about a single source.\"\"\"\n    status_icon = \"\ud83d\udd04\" if source.has_update else (\"\u2705\" if source.has_update is False else \"\u2753\")\n\n    print(f\"\\n  [{index}] {status_icon} {source.source_uri}\")\n    print(f\"      Cached: {source.is_cached}\")\n\n    if source.cached_at:\n        print(f\"      Cached at: {source.cached_at.isoformat()}\")\n\n    if source.cached_commit:\n        print(f\"      Local commit: {source.cached_commit[:8]}\")\n\n    if source.remote_commit:\n        print(f\"      Remote commit: {source.remote_commit[:8]}\")\n\n    if source.is_pinned:\n        print(\"      Pinned: Yes (version tag or commit SHA)\")\n\n    print(f\"      Summary: {source.summary}\")\n\n    if source.error:\n        print(f\"      Error: {source.error}\")\n\n\nasync def detailed_status_example():\n    \"\"\"\n    Show detailed status for each source in a bundle.\n\n    This is useful for:\n    - Debugging update issues\n    - Understanding what will change\n    - Building detailed UI displays\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"EXAMPLE 2: Detailed Source Status\")\n    print(\"=\" * 80)\n\n    # Create a bundle with git sources for demonstration\n    # In real usage, you'd load this from a bundle.yaml\n    demo_bundle = Bundle(\n        name=\"demo-with-git-sources\",\n        version=\"1.0.0\",\n        providers=[\n            {\n                \"module\": \"provider-anthropic\",\n                \"source\": \"git+https://github.com/microsoft/amplifier-module-provider-anthropic@main\",\n            }\n        ],\n        tools=[\n            {\n                \"module\": \"tool-filesystem\",\n                \"source\": \"git+https://github.com/microsoft/amplifier-module-tool-filesystem@main\",\n            }\n        ],\n    )\n\n    print(f\"\\nBundle: {demo_bundle.name}\")\n    print(\"\\nChecking status of all sources...\")\n\n    status = await check_bundle_status(demo_bundle)\n\n    print(f\"\\nSources in bundle ({len(status.sources)}):\")\n    for i, source in enumerate(status.sources, 1):\n        display_source_status(source, i)\n\n    return status\n\n\n# ============================================================================\n# Example 3: Selective Update\n# ============================================================================\n\n\nasync def selective_update_example():\n    \"\"\"\n    Demonstrate updating specific sources.\n\n    This shows the two-phase pattern:\n    1. Check status (no side effects) - inform user\n    2. Update selected sources (side effects) - user decides\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"EXAMPLE 3: Selective Update Pattern\")\n    print(\"=\" * 80)\n\n    # Create demo bundle\n    demo_bundle = Bundle(\n        name=\"selective-refresh-demo\",\n        providers=[\n            {\n                \"module\": \"provider-mock\",\n                \"source\": \"git+https://github.com/microsoft/amplifier-module-provider-mock@main\",\n            }\n        ],\n    )\n\n    # Phase 1: Check status\n    print(\"\\n[Phase 1: Checking status...]\")\n    status = await check_bundle_status(demo_bundle)\n\n    if not status.has_updates:\n        print(\"\\nAll sources are up to date!\")\n        return\n\n    # Display what's updateable\n    print(f\"\\nUpdates available for {len(status.updateable_sources)} source(s):\")\n    for source in status.updateable_sources:\n        print(f\"  - {source.source_uri}\")\n        print(f\"    {source.summary}\")\n\n    # Phase 2: App decides policy (interactive demo)\n    print(\"\\n[Phase 2: App decides what to update]\")\n    print(\"Options:\")\n    print(\"  1. Update all sources with updates\")\n    print(\"  2. Update specific sources only\")\n    print(\"  3. Skip update\")\n\n    # In real app, this would be user input or config\n    # Here we demonstrate the selective API\n    print(\"\\nDemonstrating selective update of first source only...\")\n\n    if status.updateable_sources:\n        first_source = status.updateable_sources[0].source_uri\n        print(f\"Refreshing: {first_source}\")\n\n        # Selective refresh - only specific URIs\n        await update_bundle(demo_bundle, selective=[first_source])\n\n        print(\"Done!\")\n\n\n# ============================================================================\n# Example 4: Full Update Workflow\n# ============================================================================\n\n\nasync def full_update_workflow():\n    \"\"\"\n    Complete update workflow as an app might implement it.\n\n    This shows how foundation provides mechanism while\n    the app provides policy decisions.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"EXAMPLE 4: Full Update Workflow\")\n    print(\"=\" * 80)\n\n    # Simulating app loading its configured bundle\n    print(\"\\n[Loading bundle configuration...]\")\n    bundle_path = Path(__file__).parent.parent\n    bundle = await load_bundle(str(bundle_path))\n\n    print(f\"Loaded: {bundle.name}\")\n\n    # Step 1: Check status\n    print(\"\\n[Step 1: Checking for updates...]\")\n    status = await check_bundle_status(bundle)\n\n    # Step 2: Report findings\n    print(\"\\n[Step 2: Status Report]\")\n    print(\"-\" * 40)\n    print(f\"Bundle: {status.bundle_name}\")\n    print(f\"Status: {status.summary}\")\n\n    if status.updateable_sources:\n        print(\"\\nSources with updates:\")\n        for source in status.updateable_sources:\n            print(f\"  \ud83d\udd04 {source.source_uri}\")\n            print(f\"     {source.summary}\")\n\n    if status.up_to_date_sources:\n        print(f\"\\nSources up to date: {len(status.up_to_date_sources)}\")\n\n    if status.unknown_sources:\n        print(f\"\\nSources with unknown status: {len(status.unknown_sources)}\")\n        for source in status.unknown_sources:\n            print(f\"  \u2753 {source.source_uri}: {source.summary}\")\n\n    # Step 3: App policy decision\n    print(\"\\n[Step 3: Policy Decision]\")\n    if not status.has_updates:\n        print(\"No action needed - all sources current\")\n        return None\n\n    # App decides whether to auto-update or require confirmation\n    # This is POLICY - foundation doesn't decide this\n    auto_update = False  # Example: could be from config\n\n    if auto_update:\n        print(\"Auto-update enabled - refreshing...\")\n        await update_bundle(bundle)\n        print(\"Bundle refreshed!\")\n    else:\n        print(\"Manual update required - skipping refresh\")\n        print(\"(In real app: prompt user or respect config)\")\n\n    return status\n\n\n# ============================================================================\n# Example 5: Building a CLI Update Command\n# ============================================================================\n\n\ndef print_status_table(status: BundleStatus):\n    \"\"\"Print a formatted status table.\"\"\"\n    print(f\"\\n{'Source':<60} {'Status':<20}\")\n    print(\"-\" * 80)\n\n    for source in status.sources:\n        # Truncate long URIs\n        uri = source.source_uri\n        if len(uri) > 57:\n            uri = uri[:54] + \"...\"\n\n        if source.has_update:\n            status_str = \"\ud83d\udd04 Update available\"\n        elif source.has_update is False:\n            status_str = \"\u2705 Up to date\"\n        else:\n            status_str = \"\u2753 Unknown\"\n\n        print(f\"{uri:<60} {status_str:<20}\")\n\n\nasync def cli_update_command_example():\n    \"\"\"\n    Example of how an app-cli update command might work.\n\n    Pattern:\n      amplifier update --check     # Just check, don't update\n      amplifier update             # Check and update\n      amplifier update --source X  # Update specific source\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"EXAMPLE 5: CLI Update Command Pattern\")\n    print(\"=\" * 80)\n\n    # Simulate CLI flags\n    check_only = True  # --check flag\n    specific_source = None  # --source flag\n\n    # Load current bundle\n    bundle_path = Path(__file__).parent.parent\n    bundle = await load_bundle(str(bundle_path))\n\n    print(f\"\\nChecking bundle: {bundle.name}\")\n\n    # Always check first\n    status = await check_bundle_status(bundle)\n\n    # Display status table\n    print_status_table(status)\n\n    # Summary\n    print(f\"\\n{status.summary}\")\n\n    if check_only:\n        print(\"\\n(--check flag: skipping refresh)\")\n        return status\n\n    if not status.has_updates:\n        print(\"\\nNothing to update.\")\n        return status\n\n    # Perform refresh\n    if specific_source:\n        print(f\"\\nRefreshing specific source: {specific_source}\")\n        await update_bundle(bundle, selective=[specific_source])\n    else:\n        print(f\"\\nRefreshing {len(status.updateable_sources)} source(s)...\")\n        await update_bundle(bundle)\n\n    print(\"Update complete!\")\n    return status\n\n\n# ============================================================================\n# Interactive Menu\n# ============================================================================\n\n\nasync def main():\n    \"\"\"Run interactive demo menu.\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udd04 Bundle Updates (Status Checking & Refresh)\")\n    print(\"=\" * 80)\n    print(\"\\nVALUE: Detect and apply bundle updates without rebuilding\")\n    print(\"AUDIENCE: App developers building update workflows\")\n    print(\"\\nWhat this demonstrates:\")\n    print(\"  - Checking bundle sources for updates (no side effects)\")\n    print(\"  - Getting detailed status per source\")\n    print(\"  - Refreshing sources selectively or all at once\")\n    print(\"  - Foundation mechanism + App policy pattern\")\n\n    examples = [\n        (\"Basic Status Checking\", check_status_example),\n        (\"Detailed Source Status\", detailed_status_example),\n        (\"Selective Update Pattern\", selective_update_example),\n        (\"Full Update Workflow\", full_update_workflow),\n        (\"CLI Update Command Pattern\", cli_update_command_example),\n    ]\n\n    print(\"\\n\" + \"=\" * 80)\n    print(\"Choose an example:\")\n    print(\"=\" * 80)\n    for i, (name, _) in enumerate(examples, 1):\n        print(f\"  {i}. {name}\")\n    print(\"  a. Run all examples\")\n    print(\"  q. Quit\")\n    print(\"-\" * 80)\n\n    choice = input(\"\\nYour choice: \").strip().lower()\n\n    if choice == \"q\":\n        print(\"\\n\ud83d\udc4b Goodbye!\")\n        return\n\n    if choice == \"a\":\n        for name, func in examples:\n            try:\n                await func()\n            except Exception as e:\n                print(f\"\\n\u274c Error in {name}: {e}\")\n    else:\n        try:\n            idx = int(choice) - 1\n            if 0 <= idx < len(examples):\n                _, example_func = examples[idx]\n                await example_func()\n            else:\n                print(\"\\n\u274c Invalid choice\")\n        except ValueError:\n            print(\"\\n\u274c Invalid choice\")\n\n    # Key takeaways\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udca1 KEY TAKEAWAYS\")\n    print(\"=\" * 80)\n    print(\n        \"\"\"\n1. **Two-Phase Pattern**: Check (no side effects) \u2192 Update (side effects)\n   - check_bundle_status() - safe to call anytime\n   - update_bundle() - downloads updates and reinstalls dependencies\n\n2. **Foundation = Mechanism, App = Policy**:\n   - Foundation provides: status checking, update capability\n   - App decides: when to check, whether to auto-update, which sources\n\n3. **Detailed Status Information**:\n   - cached_at, cached_commit, remote_commit\n   - has_update: True/False/None (unknown)\n   - is_pinned: detects version tags and commit SHAs\n\n4. **Selective Update**:\n   - Update all: await update_bundle(bundle)\n   - Update specific: await update_bundle(bundle, selective=[uri1, uri2])\n\n5. **Git Source Support**:\n   - Uses `git ls-remote` for efficient status checking\n   - Shallow clones for minimal bandwidth\n   - Metadata tracking for cache freshness\n\n**Production Implementation**:\n\n```python\nfrom amplifier_foundation import load_bundle, check_bundle_status, update_bundle\n\n# In your CLI update command:\nbundle = await load_bundle(\"your-bundle-uri\")\nstatus = await check_bundle_status(bundle)\n\nif status.has_updates:\n    print(f\"Updates available: {status.summary}\")\n    if user_confirms_update():\n        await update_bundle(bundle)\n        print(\"Updated!\")\n```\n\"\"\"\n    )\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "advancedOptions": {
        "provider": [
          "anthropic-sonnet",
          "anthropic-opus",
          "openai-gpt4"
        ],
        "streaming": false,
        "hooks": []
      }
    }
  },
  "execution": {
    "requiresInput": true,
    "defaultPrompt": null,
    "estimatedDuration": "2-5 seconds",
    "prerequisites": [
      "ANTHROPIC_API_KEY environment variable"
    ]
  }
}