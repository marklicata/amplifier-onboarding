{
  "id": "13_event_debugging",
  "title": "Event-Driven Debugging",
  "tier": 4,
  "category": "Real-World",
  "description": "Event-Driven Debugging",
  "estimatedTimeMinutes": 5,
  "minAudience": "developers",
  "isFeatured": false,
  "difficulty": "advanced",
  "tags": [
    "tools",
    "composition",
    "hooks"
  ],
  "githubUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/13_event_debugging.py",
  "content": {
    "everyone": {
      "title": "Event-Driven Debugging",
      "valueProposition": "Learn to work with AI agents",
      "howItWorks": [
        "Set up your AI environment",
        "Configure the agent with the right capabilities",
        "Run the example and see results",
        "Understand what happened"
      ],
      "whatYouGet": [
        "Working example you can run",
        "Clear understanding of the concept",
        "Foundation for building more"
      ]
    },
    "developers": {
      "title": "13_event_debugging.py - Event-Driven Debugging",
      "valueProposition": "",
      "howItWorks": "",
      "keyConcepts": [
        "Amplifier bundle system",
        "Module composition",
        "Session execution"
      ],
      "codeOverview": {
        "structure": [
          "Load foundation and provider bundles",
          "Execute prompts and get responses"
        ],
        "keyFunctions": [
          {
            "name": "load_bundle",
            "description": "Loads a bundle from path or URL",
            "usage": "load_bundle(str(foundation_path)"
          },
          {
            "name": "execute",
            "description": "Executes a prompt",
            "usage": "execute(prompt)"
          },
          {
            "name": "mount",
            "description": "Registers a custom tool or component",
            "usage": "mount(...)"
          }
        ]
      },
      "codeSnippet": "async def main():\n    \"\"\"Run interactive demo menu.\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udd0d Event-Driven Debugging\")\n    print(\"=\" * 80)\n    print(\"\\nVALUE: Understand and debug Amplifier's internal event flow\")\n    print(\"AUDIENCE: Developers building with Amplifier\")\n    print(\"\\nWhat this demonstrates:\")\n    print(\"  - Observing all events in an Amplifier session\")\n    print(\"  - Debugging tool execution and failures\")\n    print(\"  - Filtering events for focused debugging\")\n    print(\"  - Building custom monitoring and observability\")\n\n    scenarios = [\n        (\"Full Event Trace (see everything)\", scenario_full_event_trace),"
    },
    "experts": {
      "title": "13_event_debugging.py - Event-Driven Debugging",
      "complexity": "Tier 4 - Real-World Applications",
      "sourceUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/13_event_debugging.py",
      "architecture": "",
      "fullCode": "#!/usr/bin/env python3\n\"\"\"\nExample 13: Event-Driven Debugging\n===================================\n\nAUDIENCE: Developers debugging Amplifier integrations or building custom modules\nVALUE: Shows how to observe and debug Amplifier's internal event flow\nPATTERN: Hook-based observability and debugging\n\nWhat this demonstrates:\n  - How to observe all events flowing through Amplifier\n  - Debugging tool execution, context updates, and provider calls\n  - Understanding the event lifecycle\n  - Building custom debugging and monitoring tools\n\nWhen you'd use this:\n  - Debugging why a tool isn't being called\n  - Understanding what data flows between components\n  - Building monitoring and observability tools\n  - Troubleshooting integration issues\n  - Learning how Amplifier works internally\n\"\"\"\n\nimport asyncio\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any\n\nfrom amplifier_core import AmplifierSession\nfrom amplifier_core import HookResult\nfrom amplifier_foundation import load_bundle\n\n# ============================================================================\n# Event Debugging Utilities\n# ============================================================================\n\n\nclass EventLogger:\n    \"\"\"\n    Comprehensive event logger that captures all Amplifier events.\n\n    Features:\n    - Logs all events with timestamps\n    - Pretty-prints event data\n    - Filters events by pattern\n    - Shows event flow and timing\n    \"\"\"\n\n    def __init__(self, filter_pattern: str | None = None, verbose: bool = True):\n        self.filter_pattern = filter_pattern\n        self.verbose = verbose\n        self.events: list[dict[str, Any]] = []\n        self.start_time = datetime.now()\n\n    async def log_event(self, event: str, data: dict[str, Any]) -> HookResult:\n        \"\"\"Log an event.\"\"\"\n        # Filter if pattern specified\n        if self.filter_pattern and self.filter_pattern not in event:\n            return HookResult(action=\"continue\")\n\n        # Record event\n        timestamp = datetime.now()\n        elapsed = (timestamp - self.start_time).total_seconds()\n\n        event_record = {\n            \"event\": event,\n            \"timestamp\": timestamp.isoformat(),\n            \"elapsed\": elapsed,\n            \"data\": data,\n        }\n        self.events.append(event_record)\n\n        # Print if verbose\n        if self.verbose:\n            self._print_event(event, data, elapsed)\n\n        return HookResult(action=\"continue\")\n\n    def _print_event(self, event: str, data: dict[str, Any], elapsed: float):\n        \"\"\"Pretty-print an event.\"\"\"\n        print(f\"\\n[{elapsed:6.2f}s] \ud83d\udce1 {event}\")\n\n        # Print key data points based on event type\n        if \"tool:\" in event:\n            if \"name\" in data:\n                print(f\"           Tool: {data['name']}\")\n            if \"arguments\" in data:\n                print(f\"           Args: {self._truncate_json(data['arguments'])}\")\n            if \"result\" in data:\n                result_str = self._truncate_str(str(data.get(\"result\", \"\")))\n                print(f\"           Result: {result_str}\")\n\n        elif \"content_block:\" in event:\n            if \"type\" in data:\n                print(f\"           Type: {data['type']}\")\n            if \"text\" in data:\n                text = self._truncate_str(data[\"text\"])\n                print(f\"           Text: {text}\")\n\n        elif \"context:\" in event:\n            if \"message_count\" in data:\n                print(f\"           Messages: {data['message_count']}\")\n            if \"token_count\" in data:\n                print(f\"           Tokens: {data['token_count']}\")\n\n        elif \"session:\" in event:\n            if \"status\" in data:\n                print(f\"           Status: {data['status']}\")\n\n        # Print all data in verbose mode\n        if len(data) > 0 and self.verbose:\n            # Filter out large/noisy fields\n            filtered_data = {\n                k: v for k, v in data.items() if k not in [\"text\", \"arguments\", \"result\"] and len(str(v)) < 100\n            }\n            if filtered_data:\n                print(f\"           Data: {json.dumps(filtered_data, indent=19)}\")\n\n    def _truncate_str(self, s: str, max_len: int = 80) -> str:\n        \"\"\"Truncate a string for display.\"\"\"\n        if len(s) <= max_len:\n            return s\n        return s[:max_len] + \"...\"\n\n    def _truncate_json(self, obj: Any, max_len: int = 100) -> str:\n        \"\"\"Truncate JSON for display.\"\"\"\n        s = json.dumps(obj)\n        return self._truncate_str(s, max_len)\n\n    def print_summary(self):\n        \"\"\"Print summary of captured events.\"\"\"\n        if not self.events:\n            print(\"\\n\ud83d\udcca No events captured\")\n            return\n\n        print(\"\\n\" + \"=\" * 80)\n        print(\"\ud83d\udcca EVENT SUMMARY\")\n        print(\"=\" * 80)\n\n        # Count events by type\n        event_counts: dict[str, int] = {}\n        for record in self.events:\n            event = record[\"event\"]\n            event_counts[event] = event_counts.get(event, 0) + 1\n\n        print(f\"\\nTotal events: {len(self.events)}\")\n        print(f\"Duration: {self.events[-1]['elapsed']:.2f}s\")\n        print(\"\\nEvent breakdown:\")\n        for event, count in sorted(event_counts.items()):\n            print(f\"  {event:40} {count:3} events\")\n\n    def save_to_file(self, filename: str):\n        \"\"\"Save events to JSON file.\"\"\"\n        with open(filename, \"w\") as f:\n            json.dump(self.events, f, indent=2)\n        print(f\"\\n\ud83d\udcbe Saved {len(self.events)} events to {filename}\")\n\n\nclass EventFilter:\n    \"\"\"\n    Selective event filter for focused debugging.\n\n    Features:\n    - Filter events by category (tool, context, session, etc.)\n    - Combine multiple filters\n    - Show only specific event types\n    \"\"\"\n\n    def __init__(self, include: list[str] | None = None, exclude: list[str] | None = None):\n        self.include = include or []\n        self.exclude = exclude or []\n\n    async def filter_event(self, event: str, data: dict[str, Any]) -> HookResult:\n        \"\"\"Filter events based on include/exclude rules.\"\"\"\n        # Check exclude patterns first\n        for pattern in self.exclude:\n            if pattern in event:\n                return HookResult(action=\"continue\")  # Skip this event\n\n        # Check include patterns\n        if self.include:\n            for pattern in self.include:\n                if pattern in event:\n                    print(f\"\u2713 {event}: {self._summarize_data(data)}\")\n                    return HookResult(action=\"continue\")\n            # Not in include list, skip\n            return HookResult(action=\"continue\")\n\n        # No filters, pass through\n        print(f\"\u2713 {event}: {self._summarize_data(data)}\")\n        return HookResult(action=\"continue\")\n\n    def _summarize_data(self, data: dict[str, Any]) -> str:\n        \"\"\"Create a one-line summary of event data.\"\"\"\n        if \"name\" in data:\n            return f\"name={data['name']}\"\n        if \"type\" in data:\n            return f\"type={data['type']}\"\n        if \"status\" in data:\n            return f\"status={data['status']}\"\n        return f\"{len(data)} fields\"\n\n\n# ============================================================================\n# Demo Scenarios\n# ============================================================================\n\n\nasync def scenario_full_event_trace():\n    \"\"\"\n    Scenario: Capture complete event trace of a session.\n\n    Shows every event that flows through Amplifier.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"SCENARIO 1: Full Event Trace\")\n    print(\"=\" * 80)\n    print(\"\\nCaptures ALL events during a simple task.\")\n    print(\"Watch how tools, context, and content blocks flow through the system.\")\n    print(\"-\" * 80)\n\n    # Load foundation\n    foundation_path = Path(__file__).parent.parent\n    foundation = await load_bundle(str(foundation_path))\n\n    # Create event logger\n    logger = EventLogger(verbose=True)\n\n    # Create session with event logging hook\n    mount_plan = foundation.to_mount_plan()\n    session = AmplifierSession(config=mount_plan)\n\n    # Register logger for ALL events\n    session.coordinator.hooks.register(\"*\", logger.log_event)\n\n    await session.initialize()\n\n    prompt = \"List all Python files in the current directory using glob.\"\n\n    print(f\"\\n\ud83d\udcdd Prompt: {prompt}\")\n    print(\"\\n\" + \"-\" * 80)\n    print(\"EVENT STREAM:\")\n    print(\"-\" * 80)\n\n    try:\n        await session.execute(prompt)\n        print(\"\\n\" + \"=\" * 80)\n        print(\"\u2705 Task completed\")\n        print(\"=\" * 80)\n\n        # Show summary\n        logger.print_summary()\n\n        # Offer to save\n        save = input(\"\\n\ud83d\udcbe Save event trace to file? (y/n): \").strip().lower()\n        if save == \"y\":\n            filename = f\"event_trace_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json\"\n            logger.save_to_file(filename)\n\n    finally:\n        await session.cleanup()\n\n\nasync def scenario_tool_debugging():\n    \"\"\"\n    Scenario: Debug tool execution flow.\n\n    Shows only tool-related events for focused debugging.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"SCENARIO 2: Tool Execution Debugging\")\n    print(\"=\" * 80)\n    print(\"\\nFilters events to show only tool-related activity.\")\n    print(\"Perfect for debugging why tools aren't being called or are failing.\")\n    print(\"-\" * 80)\n\n    # Load foundation\n    foundation_path = Path(__file__).parent.parent\n    foundation = await load_bundle(str(foundation_path))\n\n    # Create focused logger\n    logger = EventLogger(filter_pattern=\"tool:\", verbose=True)\n\n    # Create session\n    mount_plan = foundation.to_mount_plan()\n    session = AmplifierSession(config=mount_plan)\n\n    # Register tool-focused logger\n    session.coordinator.hooks.register(\"*\", logger.log_event)\n\n    await session.initialize()\n\n    prompt = \"\"\"Do these tasks:\n1. Use glob to find all .py files\n2. Use read_file to read this script's main function\n3. Use grep to search for 'async def' in current directory\"\"\"\n\n    print(f\"\\n\ud83d\udcdd Prompt: {prompt}\")\n    print(\"\\n\" + \"-\" * 80)\n    print(\"TOOL EVENTS ONLY:\")\n    print(\"-\" * 80)\n\n    try:\n        await session.execute(prompt)\n        print(\"\\n\" + \"=\" * 80)\n        print(\"\u2705 Task completed\")\n        print(\"=\" * 80)\n\n        logger.print_summary()\n\n    finally:\n        await session.cleanup()\n\n\nasync def scenario_selective_filtering():\n    \"\"\"\n    Scenario: Use selective filters for specific debugging.\n\n    Shows how to include/exclude specific event patterns.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"SCENARIO 3: Selective Event Filtering\")\n    print(\"=\" * 80)\n    print(\"\\nDemonstrates include/exclude filters for focused debugging.\")\n    print(\"Useful when you know what you're looking for.\")\n    print(\"-\" * 80)\n\n    # Load foundation\n    foundation_path = Path(__file__).parent.parent\n    foundation = await load_bundle(str(foundation_path))\n\n    # Create selective filter (only content blocks, exclude deltas)\n    event_filter = EventFilter(include=[\"content_block:\"], exclude=[\"content_block:delta\"])\n\n    # Create session\n    mount_plan = foundation.to_mount_plan()\n    session = AmplifierSession(config=mount_plan)\n\n    # Register filter\n    session.coordinator.hooks.register(\"*\", event_filter.filter_event)\n\n    await session.initialize()\n\n    prompt = \"Explain what Amplifier is in one sentence.\"\n\n    print(f\"\\n\ud83d\udcdd Prompt: {prompt}\")\n    print(\"\\n\" + \"-\" * 80)\n    print(\"FILTERED EVENTS (content blocks, no deltas):\")\n    print(\"-\" * 80)\n\n    try:\n        await session.execute(prompt)\n        print(\"\\n\" + \"=\" * 80)\n        print(\"\u2705 Task completed\")\n        print(\"=\" * 80)\n\n    finally:\n        await session.cleanup()\n\n\n# ============================================================================\n# Interactive Menu\n# ============================================================================\n\n\nasync def main():\n    \"\"\"Run interactive demo menu.\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udd0d Event-Driven Debugging\")\n    print(\"=\" * 80)\n    print(\"\\nVALUE: Understand and debug Amplifier's internal event flow\")\n    print(\"AUDIENCE: Developers building with Amplifier\")\n    print(\"\\nWhat this demonstrates:\")\n    print(\"  - Observing all events in an Amplifier session\")\n    print(\"  - Debugging tool execution and failures\")\n    print(\"  - Filtering events for focused debugging\")\n    print(\"  - Building custom monitoring and observability\")\n\n    scenarios = [\n        (\"Full Event Trace (see everything)\", scenario_full_event_trace),\n        (\"Tool Debugging (tool events only)\", scenario_tool_debugging),\n        (\"Selective Filtering (custom filters)\", scenario_selective_filtering),\n    ]\n\n    print(\"\\n\" + \"=\" * 80)\n    print(\"Choose a scenario:\")\n    print(\"=\" * 80)\n    for i, (name, _) in enumerate(scenarios, 1):\n        print(f\"  {i}. {name}\")\n    print(\"  q. Quit\")\n    print(\"-\" * 80)\n\n    choice = input(\"\\nYour choice: \").strip().lower()\n\n    if choice == \"q\":\n        print(\"\\n\ud83d\udc4b Goodbye!\")\n        return\n\n    try:\n        idx = int(choice) - 1\n        if 0 <= idx < len(scenarios):\n            _, scenario_func = scenarios[idx]\n            await scenario_func()\n        else:\n            print(\"\\n\u274c Invalid choice\")\n    except ValueError:\n        print(\"\\n\u274c Invalid choice\")\n\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udca1 KEY TAKEAWAYS\")\n    print(\"=\" * 80)\n    print(\"\"\"\n1. **Hook into Everything**: Register hooks with \"*\" pattern to see all events\n2. **Filter Strategically**: Use patterns to focus on specific event types\n3. **Event Naming**: Events follow \"category:action\" pattern (tool:pre, context:update)\n4. **Debugging Flow**: Watch the sequence to understand what's happening when\n5. **Build Monitoring**: Use the same patterns for production observability\n\n**Common debugging patterns:**\n- Tool not called? \u2192 Filter \"tool:\" events to see what's registered\n- Wrong context? \u2192 Filter \"context:\" to see updates\n- Performance issues? \u2192 Log timestamps to find bottlenecks\n- Integration issues? \u2192 Full trace shows where data flow breaks\n\n**Event categories:**\n- session:* - Session lifecycle (start, end, status)\n- tool:* - Tool execution (pre, post, error)\n- content_block:* - LLM output streaming (start, delta, end)\n- context:* - Conversation context (update, compact)\n- provider:* - LLM provider calls (pre, post, error)\n\"\"\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "advancedOptions": {
        "provider": [
          "anthropic-sonnet",
          "anthropic-opus",
          "openai-gpt4"
        ],
        "streaming": false,
        "hooks": []
      }
    }
  },
  "execution": {
    "requiresInput": true,
    "defaultPrompt": null,
    "estimatedDuration": "2-5 seconds",
    "prerequisites": [
      "ANTHROPIC_API_KEY environment variable"
    ]
  }
}