{
  "id": "20_calendar_assistant",
  "title": "Calendar Integration (Meeting Assistant)",
  "tier": 4,
  "category": "Real-World",
  "description": "Calendar Integration (Meeting Assistant)",
  "estimatedTimeMinutes": 5,
  "minAudience": "developers",
  "isFeatured": false,
  "difficulty": "advanced",
  "tags": [
    "composition"
  ],
  "githubUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/20_calendar_assistant.py",
  "content": {
    "everyone": {
      "title": "Calendar Integration (Meeting Assistant)",
      "valueProposition": "Learn to work with AI agents",
      "howItWorks": [
        "Set up your AI environment",
        "Configure the agent with the right capabilities",
        "Run the example and see results",
        "Understand what happened"
      ],
      "whatYouGet": [
        "Working example you can run",
        "Clear understanding of the concept",
        "Foundation for building more"
      ]
    },
    "developers": {
      "title": "20_calendar_assistant.py - Calendar Integration (Meeting Assistant)",
      "valueProposition": "",
      "howItWorks": "",
      "keyConcepts": [
        "Amplifier bundle system",
        "Module composition",
        "Session execution"
      ],
      "codeOverview": {
        "structure": [
          "Load foundation and provider bundles",
          "Execute prompts and get responses"
        ],
        "keyFunctions": [
          {
            "name": "load_bundle",
            "description": "Loads a bundle from path or URL",
            "usage": "load_bundle(str(foundation_path)"
          },
          {
            "name": "execute",
            "description": "Executes a prompt",
            "usage": "execute(prompt)"
          },
          {
            "name": "mount",
            "description": "Registers a custom tool or component",
            "usage": "mount(...)"
          }
        ]
      },
      "codeSnippet": "async def main():\n    \"\"\"Run interactive demo menu.\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udcc6 Calendar Integration (Meeting Assistant)\")\n    print(\"=\" * 80)\n    print(\"\\nVALUE: Automate meeting scheduling and calendar management\")\n    print(\"AUDIENCE: Everyone - PMs, executives, busy professionals\")\n    print(\"\\nWhat this demonstrates:\")\n    print(\"  - Natural language to structured meeting data\")\n    print(\"  - Intelligent time slot selection\")\n    print(\"  - Automated meeting invitations\")\n    print(\"  - Meeting summaries and follow-ups\")\n\n    scenarios = [\n        (\"Schedule Meeting (full flow)\", scenario_schedule_meeting),"
    },
    "experts": {
      "title": "20_calendar_assistant.py - Calendar Integration (Meeting Assistant)",
      "complexity": "Tier 4 - Real-World Applications",
      "sourceUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/20_calendar_assistant.py",
      "architecture": "",
      "fullCode": "#!/usr/bin/env python3\n\"\"\"\nExample 20: Calendar Integration (Meeting Assistant)\n====================================================\n\nAUDIENCE: Everyone - PMs, executives, anyone who schedules meetings\nVALUE: Shows practical business automation with calendar APIs\nPATTERN: External API integration, natural language scheduling, email/calendar sync\n\nWhat this demonstrates:\n  - Integrating with external APIs (Google Calendar, Outlook)\n  - Natural language to structured data (meeting requests)\n  - Multi-step workflows (check availability, book, send invites)\n  - Real-world business automation\n\nWhen you'd use this:\n  - Meeting scheduling assistants\n  - Calendar management automation\n  - Event planning workflows\n  - Availability checking\n  - Automated reminders and follow-ups\n\"\"\"\n\nimport asyncio\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom pathlib import Path\nfrom typing import Any\n\nfrom amplifier_core import AmplifierSession\nfrom amplifier_foundation import load_bundle\n\n# ============================================================================\n# Mock Calendar API (Simulates Google Calendar / Outlook)\n# ============================================================================\n\n\nclass MockCalendar:\n    \"\"\"\n    Mock calendar API for demonstration.\n\n    In production, replace with actual Google Calendar API or Microsoft Graph API.\n    \"\"\"\n\n    def __init__(self):\n        self.events: list[dict[str, Any]] = [\n            {\n                \"id\": \"evt1\",\n                \"summary\": \"Team Standup\",\n                \"start\": datetime.now().replace(hour=9, minute=0),\n                \"end\": datetime.now().replace(hour=9, minute=30),\n                \"attendees\": [\"alice@company.com\", \"bob@company.com\"],\n            },\n            {\n                \"id\": \"evt2\",\n                \"summary\": \"Product Review\",\n                \"start\": datetime.now().replace(hour=14, minute=0),\n                \"end\": datetime.now().replace(hour=15, minute=0),\n                \"attendees\": [\"alice@company.com\", \"charlie@company.com\"],\n            },\n        ]\n\n    def get_events(self, start_date: datetime, end_date: datetime) -> list[dict[str, Any]]:\n        \"\"\"Get events in date range.\"\"\"\n        return [e for e in self.events if start_date <= e[\"start\"] <= end_date]\n\n    def find_free_slots(self, date: datetime, duration_minutes: int = 60) -> list[dict[str, Any]]:\n        \"\"\"Find available time slots.\"\"\"\n        # Simplified: just find gaps in schedule\n        business_hours = range(9, 17)  # 9 AM to 5 PM\n        day_events = [e for e in self.events if e[\"start\"].date() == date.date()]\n\n        free_slots = []\n        for hour in business_hours:\n            slot_start = date.replace(hour=hour, minute=0, second=0, microsecond=0)\n            slot_end = slot_start + timedelta(minutes=duration_minutes)\n\n            # Check if this slot conflicts with any event\n            conflicts = any(not (slot_end <= e[\"start\"] or slot_start >= e[\"end\"]) for e in day_events)\n\n            if not conflicts and slot_end.hour < 17:\n                free_slots.append(\n                    {\n                        \"start\": slot_start,\n                        \"end\": slot_end,\n                    }\n                )\n\n        return free_slots[:5]  # Return top 5 slots\n\n    def create_event(self, summary: str, start: datetime, end: datetime, attendees: list[str]) -> dict[str, Any]:\n        \"\"\"Create a calendar event.\"\"\"\n        event = {\n            \"id\": f\"evt{len(self.events) + 1}\",\n            \"summary\": summary,\n            \"start\": start,\n            \"end\": end,\n            \"attendees\": attendees,\n        }\n        self.events.append(event)\n        return event\n\n\n# ============================================================================\n# Calendar Assistant\n# ============================================================================\n\n\nclass CalendarAssistant:\n    \"\"\"\n    AI-powered calendar assistant.\n\n    Features:\n    - Parse natural language meeting requests\n    - Check availability\n    - Suggest optimal meeting times\n    - Book meetings\n    - Send meeting summaries\n    \"\"\"\n\n    def __init__(self, calendar: MockCalendar, session: AmplifierSession):\n        self.calendar = calendar\n        self.session = session\n\n    async def parse_meeting_request(self, request: str) -> dict[str, Any]:\n        \"\"\"Parse natural language meeting request into structured data.\"\"\"\n        prompt = f\"\"\"Parse this meeting request into structured data:\n\n\"{request}\"\n\nExtract:\n1. Meeting title/purpose\n2. Attendees (email addresses if mentioned, otherwise names)\n3. Duration (in minutes)\n4. Preferred date/time (or \"flexible\" if not specified)\n5. Any special requirements\n\nReturn as JSON with keys: title, attendees, duration, preferred_time, requirements\"\"\"\n\n        await self.session.execute(prompt)\n\n        # In production, use structured output or parse JSON from response\n        # For demo, we'll return a structured dict\n        return {\n            \"title\": \"Strategy Planning Session\",\n            \"attendees\": [\"alice@company.com\", \"bob@company.com\"],\n            \"duration\": 60,\n            \"preferred_time\": \"flexible\",\n            \"requirements\": \"Need projector\",\n        }\n\n    async def find_best_time(self, meeting_data: dict[str, Any]) -> dict[str, Any]:\n        \"\"\"Find the best available time for a meeting.\"\"\"\n        # Get free slots for next 3 days\n        base_date = datetime.now()\n        all_slots = []\n\n        for day_offset in range(1, 4):\n            date = base_date + timedelta(days=day_offset)\n            slots = self.calendar.find_free_slots(date, meeting_data[\"duration\"])\n            all_slots.extend(slots)\n\n        if not all_slots:\n            return {\"error\": \"No available slots found\"}\n\n        # Ask AI to pick the best slot\n        slots_desc = \"\\n\".join(\n            [\n                f\"{i + 1}. {slot['start'].strftime('%A, %B %d at %I:%M %p')} - {slot['end'].strftime('%I:%M %p')}\"\n                for i, slot in enumerate(all_slots)\n            ]\n        )\n\n        prompt = f\"\"\"Given these available time slots for a meeting:\n\n{slots_desc}\n\nMeeting details:\n- Title: {meeting_data[\"title\"]}\n- Duration: {meeting_data[\"duration\"]} minutes\n- Attendees: {\", \".join(meeting_data[\"attendees\"])}\n\nWhich slot is best? Consider:\n- Avoiding back-to-back meetings (prefer slots with buffers)\n- Mid-morning or mid-afternoon often work well\n- Avoiding Monday mornings and Friday afternoons\n\nRespond with just the slot number (1-{len(all_slots)}).\"\"\"\n\n        response = await self.session.execute(prompt)\n\n        # Parse response (simplified)\n        try:\n            slot_num = int(response.strip().split()[0]) - 1\n            if 0 <= slot_num < len(all_slots):\n                return all_slots[slot_num]\n        except Exception:\n            pass\n\n        # Fallback to first slot\n        return all_slots[0]\n\n    async def create_meeting_invitation(self, meeting_data: dict[str, Any], time_slot: dict[str, Any]) -> str:\n        \"\"\"Generate a meeting invitation email.\"\"\"\n        prompt = f\"\"\"Write a professional meeting invitation email:\n\nMeeting: {meeting_data[\"title\"]}\nDate/Time: {time_slot[\"start\"].strftime(\"%A, %B %d, %Y at %I:%M %p\")}\nDuration: {meeting_data[\"duration\"]} minutes\nAttendees: {\", \".join(meeting_data[\"attendees\"])}\nRequirements: {meeting_data.get(\"requirements\", \"None\")}\n\nInclude:\n- Clear subject line\n- Meeting purpose\n- Agenda items (infer from title)\n- Calendar details\n- Any prep needed\n- Friendly, professional tone\n\nKeep it concise.\"\"\"\n\n        invitation = await self.session.execute(prompt)\n        return invitation\n\n\n# ============================================================================\n# Demo Scenarios\n# ============================================================================\n\n\nasync def scenario_schedule_meeting():\n    \"\"\"\n    Scenario: Schedule a meeting from natural language.\n\n    Full flow: parse request \u2192 find time \u2192 book \u2192 send invite.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"SCENARIO 1: Schedule Meeting from Natural Language\")\n    print(\"=\" * 80)\n\n    # Initialize\n    calendar = MockCalendar()\n    foundation_path = Path(__file__).parent.parent\n    foundation = await load_bundle(str(foundation_path))\n    mount_plan = foundation.to_mount_plan()\n\n    session = AmplifierSession(config=mount_plan)\n    await session.initialize()\n\n    assistant = CalendarAssistant(calendar, session)\n\n    # Natural language request\n    request = \"\"\"Can you schedule a strategy planning session with Alice and Bob?\n    We need about an hour, and sometime next week would be great.\n    We'll need a room with a projector.\"\"\"\n\n    print(\"\\n\ud83d\udcdd Meeting Request:\")\n    print(f'   \"{request}\"')\n    print(\"\\n\" + \"-\" * 80)\n\n    # Step 1: Parse request\n    print(\"\\n[1/4] Parsing meeting request...\")\n    meeting_data = await assistant.parse_meeting_request(request)\n    print(f\"   \u2713 Title: {meeting_data['title']}\")\n    print(f\"   \u2713 Attendees: {', '.join(meeting_data['attendees'])}\")\n    print(f\"   \u2713 Duration: {meeting_data['duration']} minutes\")\n\n    # Step 2: Find available time\n    print(\"\\n[2/4] Finding available time slots...\")\n    time_slot = await assistant.find_best_time(meeting_data)\n    if \"error\" in time_slot:\n        print(f\"   \u2717 {time_slot['error']}\")\n        return\n\n    print(f\"   \u2713 Best time: {time_slot['start'].strftime('%A, %B %d at %I:%M %p')}\")\n\n    # Step 3: Book the meeting\n    print(\"\\n[3/4] Booking meeting...\")\n    event = calendar.create_event(\n        summary=meeting_data[\"title\"],\n        start=time_slot[\"start\"],\n        end=time_slot[\"end\"],\n        attendees=meeting_data[\"attendees\"],\n    )\n    print(f\"   \u2713 Meeting booked (ID: {event['id']})\")\n\n    # Step 4: Generate invitation\n    print(\"\\n[4/4] Generating meeting invitation...\")\n    invitation = await assistant.create_meeting_invitation(meeting_data, time_slot)\n\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\u2705 MEETING SCHEDULED\")\n    print(\"=\" * 80)\n    print(\"\\n\ud83d\udce7 Invitation Email:\")\n    print(\"-\" * 80)\n    print(invitation)\n\n    await session.cleanup()\n\n\nasync def scenario_check_availability():\n    \"\"\"\n    Scenario: Check availability and suggest times.\n\n    Shows calendar inspection and intelligent scheduling.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"SCENARIO 2: Check Availability\")\n    print(\"=\" * 80)\n\n    calendar = MockCalendar()\n    foundation_path = Path(__file__).parent.parent\n    foundation = await load_bundle(str(foundation_path))\n    mount_plan = foundation.to_mount_plan()\n\n    session = AmplifierSession(config=mount_plan)\n    await session.initialize()\n\n    # Show today's schedule\n    print(\"\\n\ud83d\udcc5 Today's Schedule:\")\n    print(\"-\" * 80)\n    today_start = datetime.now().replace(hour=0, minute=0, second=0)\n    today_end = datetime.now().replace(hour=23, minute=59, second=59)\n\n    events = calendar.get_events(today_start, today_end)\n    for event in events:\n        print(f\"  {event['start'].strftime('%I:%M %p')} - {event['end'].strftime('%I:%M %p')}: {event['summary']}\")\n\n    # Find free slots\n    print(\"\\n\ud83d\udd0d Available Time Slots (60 min meetings):\")\n    print(\"-\" * 80)\n\n    free_slots = calendar.find_free_slots(datetime.now(), duration_minutes=60)\n    for i, slot in enumerate(free_slots, 1):\n        print(f\"  {i}. {slot['start'].strftime('%I:%M %p')} - {slot['end'].strftime('%I:%M %p')}\")\n\n    # Ask AI for recommendation\n    slots_desc = \"\\n\".join([f\"{i}. {slot['start'].strftime('%I:%M %p')}\" for i, slot in enumerate(free_slots, 1)])\n\n    prompt = f\"\"\"Looking at my schedule today:\n\nBusy times:\n{chr(10).join([f\"- {e['start'].strftime('%I:%M %p')}: {e['summary']}\" for e in events])}\n\nAvailable slots:\n{slots_desc}\n\nSomeone wants to schedule a 1-hour meeting. Which slot would you recommend and why?\nConsider energy levels, lunch breaks, and buffer time.\"\"\"\n\n    print(\"\\n\ud83d\udcad AI Recommendation:\")\n    print(\"-\" * 80)\n\n    recommendation = await session.execute(prompt)\n    print(recommendation)\n\n    await session.cleanup()\n\n\nasync def scenario_meeting_summary():\n    \"\"\"\n    Scenario: Generate meeting summary and action items.\n\n    Post-meeting workflow automation.\n    \"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"SCENARIO 3: Meeting Summary & Follow-up\")\n    print(\"=\" * 80)\n\n    # Simulated meeting notes\n    meeting_notes = \"\"\"\nMeeting: Product Roadmap Q1 2024\nDate: Today, 2:00 PM\nAttendees: Alice (PM), Bob (Eng), Charlie (Design)\n\nDiscussion:\n- Reviewed user feedback from beta launch\n- Prioritized features for Q1: mobile app, API v2, dashboard redesign\n- Bob raised concerns about API timeline - might need extra sprint\n- Charlie showed mockups for new dashboard\n- Alice will draft PRD for mobile app by Friday\n\nAction Items:\n- Alice: Draft mobile app PRD (Due: Friday)\n- Bob: Technical spike for API v2 (Due: Next Monday)\n- Charlie: Finalize dashboard mockups (Due: Next Wednesday)\n- All: Review and comment on Jira tickets by EOW\n\nNext Meeting: January 15, 2024 (2 weeks)\n\"\"\"\n\n    print(\"\\n\ud83d\udcdd Raw Meeting Notes:\")\n    print(\"-\" * 80)\n    print(meeting_notes[:300] + \"...\")\n\n    foundation_path = Path(__file__).parent.parent\n    foundation = await load_bundle(str(foundation_path))\n    mount_plan = foundation.to_mount_plan()\n\n    session = AmplifierSession(config=mount_plan)\n    await session.initialize()\n\n    # Generate structured summary\n    prompt = f\"\"\"Create a polished meeting summary from these notes:\n\n{meeting_notes}\n\nGenerate:\n1. Executive Summary (2-3 sentences)\n2. Key Decisions Made\n3. Action Items (with owners and due dates)\n4. Next Steps\n5. Follow-up email to attendees\n\nFormat professionally and concisely.\"\"\"\n\n    print(\"\\n\u23f3 Generating summary...\")\n\n    summary = await session.execute(prompt)\n\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\u2705 MEETING SUMMARY\")\n    print(\"=\" * 80)\n    print(summary)\n\n    await session.cleanup()\n\n\n# ============================================================================\n# Interactive Menu\n# ============================================================================\n\n\nasync def main():\n    \"\"\"Run interactive demo menu.\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udcc6 Calendar Integration (Meeting Assistant)\")\n    print(\"=\" * 80)\n    print(\"\\nVALUE: Automate meeting scheduling and calendar management\")\n    print(\"AUDIENCE: Everyone - PMs, executives, busy professionals\")\n    print(\"\\nWhat this demonstrates:\")\n    print(\"  - Natural language to structured meeting data\")\n    print(\"  - Intelligent time slot selection\")\n    print(\"  - Automated meeting invitations\")\n    print(\"  - Meeting summaries and follow-ups\")\n\n    scenarios = [\n        (\"Schedule Meeting (full flow)\", scenario_schedule_meeting),\n        (\"Check Availability\", scenario_check_availability),\n        (\"Meeting Summary & Follow-up\", scenario_meeting_summary),\n    ]\n\n    print(\"\\n\" + \"=\" * 80)\n    print(\"Choose a scenario:\")\n    print(\"=\" * 80)\n    for i, (name, _) in enumerate(scenarios, 1):\n        print(f\"  {i}. {name}\")\n    print(\"  q. Quit\")\n    print(\"-\" * 80)\n\n    choice = input(\"\\nYour choice: \").strip().lower()\n\n    if choice == \"q\":\n        print(\"\\n\ud83d\udc4b Goodbye!\")\n        return\n\n    try:\n        idx = int(choice) - 1\n        if 0 <= idx < len(scenarios):\n            _, scenario_func = scenarios[idx]\n            await scenario_func()\n        else:\n            print(\"\\n\u274c Invalid choice\")\n    except ValueError:\n        print(\"\\n\u274c Invalid choice\")\n\n    print(\"\\n\" + \"=\" * 80)\n    print(\"\ud83d\udca1 KEY TAKEAWAYS\")\n    print(\"=\" * 80)\n    print(\"\"\"\n1. **Natural Language \u2192 Action**: Users describe what they want, AI handles details\n2. **Multi-Step Workflows**: Parse \u2192 Find time \u2192 Book \u2192 Notify\n3. **Real-World Integration**: Works with actual calendar APIs (Google, Outlook)\n4. **Business Value**: Saves time, reduces scheduling friction\n\n**Implementation with real calendars:**\n\nGoogle Calendar:\n```python\nfrom google.oauth2.credentials import Credentials\nfrom googleapiclient.discovery import build\n\nservice = build('calendar', 'v3', credentials=creds)\nevents = service.events().list(calendarId='primary').execute()\n```\n\nMicrosoft Outlook:\n```python\nimport requests\nheaders = {'Authorization': f'Bearer {access_token}'}\nresponse = requests.get(\n    'https://graph.microsoft.com/v1.0/me/calendar/events',\n    headers=headers\n)\n```\n\n**Production considerations:**\n- OAuth authentication flow\n- Handle timezones properly\n- Respect user permissions\n- Rate limiting and retries\n- Privacy and data protection\n- Integration with email for invites\n\n**Use cases:**\n- Executive assistants (automate scheduling)\n- Team meeting coordination\n- Interview scheduling\n- Event planning\n- Calendar optimization (suggest better meeting times)\n- Meeting prep and follow-up automation\n\"\"\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "advancedOptions": {
        "provider": [
          "anthropic-sonnet",
          "anthropic-opus",
          "openai-gpt4"
        ],
        "streaming": false,
        "hooks": []
      }
    }
  },
  "execution": {
    "requiresInput": true,
    "defaultPrompt": null,
    "estimatedDuration": "2-5 seconds",
    "prerequisites": [
      "ANTHROPIC_API_KEY environment variable"
    ]
  }
}