{
  "id": "07_full_workflow",
  "title": "Complete workflow - load, compose, prepare, execute.",
  "tier": 2,
  "category": "Foundation Concepts",
  "description": "Complete workflow - load, compose, prepare, execute.",
  "estimatedTimeMinutes": 5,
  "minAudience": "everyone",
  "isFeatured": false,
  "difficulty": "intermediate",
  "tags": [
    "tools",
    "composition",
    "hooks",
    "internals"
  ],
  "githubUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/07_full_workflow.py",
  "content": {
    "everyone": {
      "title": "Complete workflow - load, compose, prepare, execute.",
      "valueProposition": "Learn to work with AI agents",
      "howItWorks": [
        "Set up your AI environment",
        "Configure the agent with the right capabilities",
        "Run the example and see results",
        "Understand what happened"
      ],
      "whatYouGet": [
        "Working example you can run",
        "Clear understanding of the concept",
        "Foundation for building more"
      ]
    },
    "developers": {
      "title": "07_full_workflow.py - Complete workflow - load, compose, prepare, execute.",
      "valueProposition": "",
      "howItWorks": "The full prepare() \u2192 create_session() \u2192 execute() flow",
      "keyConcepts": [
        "Amplifier bundle system",
        "Module composition",
        "Session execution"
      ],
      "codeOverview": {
        "structure": [
          "Load foundation and provider bundles",
          "Compose bundles together",
          "Prepare modules (download if needed)",
          "Create AI session",
          "Execute prompts and get responses"
        ],
        "keyFunctions": [
          {
            "name": "load_bundle",
            "description": "Loads a bundle from path or URL",
            "usage": "load_bundle(str(foundation_path)"
          },
          {
            "name": "compose",
            "description": "Combines multiple bundles",
            "usage": "compose(foundation_path: Path, provider_path: Path)"
          },
          {
            "name": "prepare",
            "description": "Downloads and activates modules",
            "usage": "prepare()"
          },
          {
            "name": "create_session",
            "description": "Creates an AI session",
            "usage": "create_session()"
          },
          {
            "name": "execute",
            "description": "Executes a prompt",
            "usage": "execute()"
          },
          {
            "name": "mount",
            "description": "Registers a custom tool or component",
            "usage": "mount(...)"
          }
        ]
      },
      "codeSnippet": "async def main() -> None:\n    \"\"\"Interactive end-to-end demo.\"\"\"\n    print(\"=\" * 60)\n    print(\"Amplifier Foundation: Full Workflow Demo\")\n    print(\"=\" * 60)\n\n    # Step 1: Load foundation\n    foundation_path = Path(__file__).parent.parent.parent\n    print(f\"\\n[1/4] Loading foundation from: {foundation_path}\")\n    foundation = await load_bundle(str(foundation_path))\n    print(f\"      Loaded: {foundation.name} v{foundation.version}\")\n\n    # Step 2: Discover and select provider\n    print(\"\\n[2/4] Discovering providers...\")\n    providers = discover_providers(foundation)"
    },
    "experts": {
      "title": "07_full_workflow.py - Complete workflow - load, compose, prepare, execute.",
      "complexity": "Tier 2 - Foundation Concepts",
      "sourceUrl": "https://github.com/microsoft/amplifier-foundation/blob/main/examples/07_full_workflow.py",
      "architecture": "The full prepare() \u2192 create_session() \u2192 execute() flow",
      "fullCode": "#!/usr/bin/env python3\n\"\"\"Example 4: Complete workflow - load, compose, prepare, execute.\n\nTEACHABLE MOMENT: The full prepare() \u2192 create_session() \u2192 execute() flow\n\nThis is the SINGLE SOURCE for understanding:\n- Bundle.prepare() - resolves all module sources, returns PreparedBundle\n- PreparedBundle.create_session() - creates AmplifierSession with mount plan\n- session.execute(prompt) - runs the LLM interaction\n\nOPTIONAL ADVANCED features (marked clearly):\n- @mention processing - loading files referenced in prompts\n- spawn capability - sub-session delegation for agents\n\nRequirements:\n- ANTHROPIC_API_KEY or OPENAI_API_KEY environment variable set\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport os\nfrom pathlib import Path\nfrom typing import Any\n\nfrom amplifier_foundation import Bundle\nfrom amplifier_foundation import load_bundle\nfrom amplifier_foundation.bundle import PreparedBundle\n\n# =============================================================================\n# SECTION 1: FOUNDATION MECHANISM (The essential pattern - copy this)\n# =============================================================================\n\n\nasync def load_and_compose(foundation_path: Path, provider_path: Path) -> Bundle:\n    \"\"\"Load foundation and provider bundles, compose them together.\n\n    Args:\n        foundation_path: Path to foundation bundle\n        provider_path: Path to provider bundle (e.g., providers/anthropic.yaml)\n\n    Returns:\n        Composed bundle ready for prepare()\n    \"\"\"\n    foundation = await load_bundle(str(foundation_path))\n    provider = await load_bundle(str(provider_path))\n    return foundation.compose(provider)\n\n\nasync def prepare_and_execute(composed: Bundle, prompt: str) -> str:\n    \"\"\"The core workflow: prepare \u2192 create_session \u2192 execute.\n\n    This is the essential pattern for using amplifier-foundation.\n\n    Args:\n        composed: A composed bundle with providers configured\n        prompt: User prompt to execute\n\n    Returns:\n        LLM response text\n    \"\"\"\n    # prepare() resolves all module sources (downloads if needed)\n    prepared = await composed.prepare()\n\n    # create_session() creates AmplifierSession with the mount plan\n    session = await prepared.create_session()\n\n    # execute() runs the prompt through the LLM\n    async with session:\n        response = await session.execute(prompt)\n        return response\n\n\n# =============================================================================\n# SECTION 2: APP-LAYER HELPERS (Customize for your app)\n# =============================================================================\n\n\ndef discover_providers(bundle: Bundle) -> list[dict[str, Any]]:\n    \"\"\"Discover available provider bundles from foundation's providers/ directory.\"\"\"\n    if not bundle.base_path:\n        return []\n\n    providers_dir = bundle.base_path / \"providers\"\n    if not providers_dir.exists():\n        return []\n\n    providers = []\n    for provider_file in sorted(providers_dir.glob(\"*.yaml\")):\n        import yaml\n\n        with open(provider_file) as f:\n            data = yaml.safe_load(f)\n\n        bundle_info = data.get(\"bundle\", {})\n        provider_config = data.get(\"providers\", [{}])[0]\n        module = provider_config.get(\"module\", \"\")\n\n        # Determine required env var\n        env_var = \"ANTHROPIC_API_KEY\" if \"anthropic\" in module else \"OPENAI_API_KEY\"\n\n        providers.append(\n            {\n                \"name\": bundle_info.get(\"name\", provider_file.stem),\n                \"model\": provider_config.get(\"config\", {}).get(\"default_model\", \"unknown\"),\n                \"file\": provider_file,\n                \"env_var\": env_var,\n                \"env_set\": bool(os.environ.get(env_var)),\n            }\n        )\n\n    return providers\n\n\ndef select_provider_interactive(providers: list[dict[str, Any]]) -> dict[str, Any] | None:\n    \"\"\"Interactive provider selection.\"\"\"\n    print(\"\\nAvailable providers:\")\n    for i, p in enumerate(providers, 1):\n        status = \"[OK]\" if p[\"env_set\"] else \"[MISSING KEY]\"\n        print(f\"  [{i}] {p['name']} ({p['model']}) {status}\")\n\n    while True:\n        choice = input(f\"\\nSelect [1-{len(providers)}] or 'q' to quit: \")\n        if choice.lower() == \"q\":\n            return None\n        try:\n            idx = int(choice) - 1\n            if 0 <= idx < len(providers):\n                return providers[idx]\n        except ValueError:\n            pass\n        print(\"Invalid selection.\")\n\n\n# =============================================================================\n# SECTION 3: OPTIONAL ADVANCED - @Mention Processing\n# =============================================================================\n\n\nasync def process_mentions(session: Any, prompt: str, foundation: Bundle) -> None:\n    \"\"\"OPTIONAL: Process @mentions in prompt and add file context to session.\n\n    This is APP-LAYER POLICY for handling @file references.\n    Skip this section if you don't need @mention support.\n\n    Supported @mention types:\n    - @filename.txt - loads file content\n    - @path/to/file.md - loads file at path\n    - @directory/ - loads directory listing (files/subdirs, NOT contents)\n    - @bundle:resource - loads resource from registered bundle\n\n    Directory @mentions provide awareness of available files without\n    flooding context with all file contents.\n    \"\"\"\n    from amplifier_foundation.mentions import BaseMentionResolver\n    from amplifier_foundation.mentions import ContentDeduplicator\n    from amplifier_foundation.mentions import format_context_block\n    from amplifier_foundation.mentions import load_mentions\n    from amplifier_foundation.mentions import parse_mentions\n\n    mentions = parse_mentions(prompt)\n    if not mentions:\n        return\n\n    print(f\"  Processing {len(mentions)} @mention(s)...\")\n\n    resolver = BaseMentionResolver(\n        bundles={\"foundation\": foundation},\n        base_path=Path.cwd(),\n    )\n    deduplicator = ContentDeduplicator()\n\n    results = await load_mentions(\n        text=prompt,\n        resolver=resolver,\n        deduplicator=deduplicator,\n        relative_to=Path.cwd(),\n    )\n\n    mention_to_path = {r.mention: r.resolved_path for r in results if r.resolved_path}\n    context_block = format_context_block(deduplicator, mention_to_path)\n\n    if context_block:\n        context = session.coordinator.get(\"context\")\n        await context.add_message(\n            {\n                \"role\": \"system\",\n                \"content\": f\"Referenced files:\\n\\n{context_block}\",\n            }\n        )\n        unique_files = deduplicator.get_unique_files()\n        dir_count = sum(1 for f in unique_files if f.content.startswith(\"Directory:\"))\n        file_count = len(unique_files) - dir_count\n        parts = []\n        if file_count:\n            parts.append(f\"{file_count} file(s)\")\n        if dir_count:\n            parts.append(f\"{dir_count} directory listing(s)\")\n        print(f\"  Loaded {', '.join(parts)}\")\n\n\n# =============================================================================\n# SECTION 4: OPTIONAL ADVANCED - Sub-Session Spawning\n# =============================================================================\n\n\ndef register_spawn_capability(session: Any, prepared: PreparedBundle) -> None:\n    \"\"\"OPTIONAL: Register spawn capability for agent delegation.\n\n    This enables the task tool to spawn sub-sessions for agents.\n    Skip this section if you don't need agent delegation.\n    \"\"\"\n\n    async def spawn_capability(\n        agent_name: str,\n        instruction: str,\n        parent_session: Any,\n        agent_configs: dict[str, dict[str, Any]],\n        sub_session_id: str | None = None,\n    ) -> dict[str, Any]:\n        \"\"\"Spawn sub-session for agent.\"\"\"\n        # Resolve agent name to Bundle (APP-LAYER POLICY)\n        if agent_name in agent_configs:\n            config = agent_configs[agent_name]\n        elif agent_name in prepared.bundle.agents:\n            config = prepared.bundle.agents[agent_name]\n        else:\n            available = list(agent_configs.keys()) + list(prepared.bundle.agents.keys())\n            raise ValueError(f\"Agent '{agent_name}' not found. Available: {available}\")\n\n        child_bundle = Bundle(\n            name=agent_name,\n            version=\"1.0.0\",\n            session=config.get(\"session\", {}),\n            providers=config.get(\"providers\", []),\n            tools=config.get(\"tools\", []),\n            hooks=config.get(\"hooks\", []),\n            instruction=config.get(\"instruction\") or config.get(\"system\", {}).get(\"instruction\"),\n        )\n\n        return await prepared.spawn(\n            child_bundle=child_bundle,\n            instruction=instruction,\n            session_id=sub_session_id,\n            parent_session=parent_session,\n        )\n\n    session.coordinator.register_capability(\"session.spawn\", spawn_capability)\n\n\n# =============================================================================\n# MAIN: Interactive Demo\n# =============================================================================\n\n\nasync def main() -> None:\n    \"\"\"Interactive end-to-end demo.\"\"\"\n    print(\"=\" * 60)\n    print(\"Amplifier Foundation: Full Workflow Demo\")\n    print(\"=\" * 60)\n\n    # Step 1: Load foundation\n    foundation_path = Path(__file__).parent.parent.parent\n    print(f\"\\n[1/4] Loading foundation from: {foundation_path}\")\n    foundation = await load_bundle(str(foundation_path))\n    print(f\"      Loaded: {foundation.name} v{foundation.version}\")\n\n    # Step 2: Discover and select provider\n    print(\"\\n[2/4] Discovering providers...\")\n    providers = discover_providers(foundation)\n    if not providers:\n        print(\"      No providers found!\")\n        return\n\n    selected = select_provider_interactive(providers)\n    if not selected:\n        print(\"\\nExiting.\")\n        return\n\n    if not selected[\"env_set\"]:\n        print(f\"\\n  WARNING: {selected['env_var']} not set. Provider may fail.\")\n\n    # Step 3: Compose and prepare\n    print(f\"\\n[3/4] Composing foundation + {selected['name']}...\")\n    composed = foundation.compose(await load_bundle(str(selected[\"file\"])))\n\n    print(\"      Preparing (downloading modules if needed)...\")\n    prepared = await composed.prepare()\n    print(\"      Ready!\")\n\n    # Step 4: Execute\n    print(\"\\n[4/4] Enter prompt (or 'q' to quit):\")\n    prompt = input(\"> \")\n    if prompt.lower() == \"q\":\n        print(\"\\nExiting.\")\n        return\n\n    print(\"\\n      Executing...\")\n    try:\n        session = await prepared.create_session()\n\n        # OPTIONAL: Register advanced features\n        register_spawn_capability(session, prepared)\n\n        async with session:\n            # OPTIONAL: Process @mentions\n            await process_mentions(session, prompt, foundation)\n\n            response = await session.execute(prompt)\n\n        print(\"\\n\" + \"-\" * 60)\n        print(\"Response:\")\n        print(\"-\" * 60)\n        print(response)\n\n    except ImportError:\n        print(\"\\n  ERROR: amplifier-core not installed\")\n        print(\"  Install with: pip install amplifier-core\")\n    except Exception as e:\n        print(f\"\\n  ERROR: {e}\")\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Demo complete\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n",
      "advancedOptions": {
        "provider": [
          "anthropic-sonnet",
          "anthropic-opus",
          "openai-gpt4"
        ],
        "streaming": false,
        "hooks": []
      }
    }
  },
  "execution": {
    "requiresInput": true,
    "defaultPrompt": null,
    "estimatedDuration": "2-5 seconds",
    "prerequisites": [
      "ANTHROPIC_API_KEY environment variable"
    ]
  }
}